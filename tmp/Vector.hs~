{-|
	Licence Information

	This file is part of Numerikell 1.0.0.0 Haskell Numerical
	Software project. Please do not share, copy, edit or distribute
	without owner's permission.  

	@Contributors : Please striclty follow Haskell community convention.
	Comment your code, use proper nomenclature for functions, variables
	and modules.

	File Specification :
	Contributor : Dipendra K. Misra (dipendrakumarmisra@gmail.com), Mukul Singh, Satyendra Patel
-}

module Vector where

type Vector = [Double]

-- dot product of two vectors
dotV :: Vector -> Vector -> Double
dotV [] _ = 0
dotV _ [] = 0
dotV (x:xs) (y:ys) = x*y + dotV xs ys

-- return difference of two vector
subV :: Vector -> Vector -> Vector
subV [] (x:xs) = map (\x -> -x) (x:xs)
subV (x:xs) [] =  (x:xs) 
subV (x:xs) (y:ys) = (x-y) : subV xs ys      

-- return addition of two vector
addV :: Vector -> Vector -> Vector
addV [] (x:xs) = (x:xs)	
addV (x:xs) [] = (x:xs)	
addV (x:xs) (y:ys) = (x+y) : addV xs ys


-- apply a function, component wise on two vectors
appV :: (Double -> Double -> Double) -> Vector -> Vector -> Vector
appV _ [] _ = []
appV _ _ [] = []
appV f (x:xs) (y:ys) = (f x y) : (appV f xs ys)


-- size of a vector
sizeV :: Vector -> Int
sizeV  = foldl (\acc  t-> acc+1) 0

-- return vector i
i :: Vector
i  = [1,0,0]

-- return vector j
j :: Vector
j  = [0,1,0]

-- return vector k
k :: Vector
k  = [0,0,1]

-- cross product of two vectors
cross :: Vector -> Vector -> Vector
cross [x1,x2,x3] [y1,y2,y3] = [x2*y3-x3*y2, x3*y1-x1*y3, x1*y2-x2*y1]

-- normalized distance of a vector
norm :: Vector-> Double
norm = sqrt. foldl (\acc t -> acc + t*t) 0

-- find a unit vector along the vector
unity :: Vector -> Vector
unity x = map (\t -> t/normalized) x
        where  normalized = norm x
